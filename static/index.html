<!DOCTYPE html>
<html>
  <head>
    <title>Real-Time Voice Changer</title>
  </head>
  <body>
    <h1>Real-Time Voice Changer</h1>
    <label for="inputSelect">Select Input Device:</label>
    <select id="inputSelect"></select>
    <br /><br />
    <label for="outputSelect">Select Output Device:</label>
    <select id="outputSelect"></select>
    <br /><br />
    <button id="startButton">Start Voice Conversion</button>
    <button id="stopButton">Stop Voice Conversion</button>

    <script>
      let ws;
      let mediaStream;
      let audioContext;
      let processor;
      let source;
      let audioQueue = [];

      // Function to populate the input and output device lists
      async function populateDeviceLists() {
        if (
          !navigator.mediaDevices ||
          !navigator.mediaDevices.enumerateDevices
        ) {
          console.log("enumerateDevices() not supported.");
          return;
        }

        const devices = await navigator.mediaDevices.enumerateDevices();
        const inputSelect = document.getElementById("inputSelect");
        const outputSelect = document.getElementById("outputSelect");

        // Clear existing options
        inputSelect.innerHTML = "";
        outputSelect.innerHTML = "";

        // Create default option
        const defaultInputOption = document.createElement("option");
        defaultInputOption.value = "";
        defaultInputOption.text = "Default Input Device";
        inputSelect.appendChild(defaultInputOption);

        const defaultOutputOption = document.createElement("option");
        defaultOutputOption.value = "";
        defaultOutputOption.text = "Default Output Device";
        outputSelect.appendChild(defaultOutputOption);

        devices.forEach((device) => {
          const option = document.createElement("option");
          option.value = device.deviceId;
          if (device.kind === "audioinput") {
            option.text = device.label || `Microphone ${inputSelect.length}`;
            inputSelect.appendChild(option);
          } else if (device.kind === "audiooutput") {
            option.text = device.label || `Speaker ${outputSelect.length}`;
            outputSelect.appendChild(option);
          }
        });
      }

      // Call the function to populate device lists
      populateDeviceLists();

      // Event listener for the Start button
      document.getElementById("startButton").onclick = async () => {
        // Get selected device IDs
        const inputSelect = document.getElementById("inputSelect");
        const inputDeviceId = inputSelect.value;

        const outputSelect = document.getElementById("outputSelect");
        const outputDeviceId = outputSelect.value;

        // WebSocket connection
        ws = new WebSocket(`ws://${window.location.host}/ws`);
        ws.binaryType = "arraybuffer";

        // Constraints for getUserMedia
        const constraints = {
          audio: {
            deviceId: inputDeviceId ? { exact: inputDeviceId } : undefined,
          },
        };

        mediaStream = await navigator.mediaDevices.getUserMedia(constraints);

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const sampleRate = audioContext.sampleRate; // Typically 44100 Hz or 48000 Hz

        await audioContext.audioWorklet.addModule("/static/processor.js");
        processor = new AudioWorkletNode(audioContext, "voice-processor");

        source = audioContext.createMediaStreamSource(mediaStream);
        source.connect(processor);

        // Create a GainNode to control volume (optional)
        const gainNode = audioContext.createGain();

        // Connect processor to gainNode
        processor.connect(gainNode);

        // Set the output device if sinkId is supported and output device is selected
        if ("setSinkId" in audioContext.destination) {
          try {
            const sinkId = outputDeviceId || "default";
            await audioContext.destination.setSinkId(sinkId);
            console.log(`Output device set to ${sinkId}`);
          } catch (err) {
            console.error(`Failed to set output device: ${err}`);
          }
        } else {
          console.warn("setSinkId is not supported in your browser.");
        }

        gainNode.connect(audioContext.destination);

        // processor.port.onmessage = (event) => {
        //   const inputBuffer = event.data;
        //   // Send audio data to server
        //   if (ws.readyState === WebSocket.OPEN) {
        //     ws.send(inputBuffer);
        //   }
        // };

        processor.port.onmessage = (event) => {
          const inputBuffer = event.data;
          audioQueue.push(inputBuffer);
          playAudioQueue();
        };

        ws.onmessage = function (event) {
          let arrayBuffer = event.data;
          audioQueue.push(arrayBuffer);
          playAudioQueue();
        };

        ws.onclose = function () {
          console.log("WebSocket connection closed.");
        };
      };

      function playAudioQueue() {
        if (audioQueue.length > 0) {
          let arrayBuffer = audioQueue.shift();

          // Convert the ArrayBuffer to Float32Array
          let float32Array = new Float32Array(arrayBuffer);

          // Create an AudioBuffer
          let audioBuffer = audioContext.createBuffer(
            1,
            float32Array.length,
            audioContext.sampleRate
          );

          // Copy the PCM data into the AudioBuffer
          audioBuffer.getChannelData(0).set(float32Array);

          // Create a BufferSource and play the audio
          let outputSource = audioContext.createBufferSource();
          outputSource.buffer = audioBuffer;

          // Connect to gainNode instead of audioContext.destination
          outputSource.connect(audioContext.destination);

          // Schedule playback
          let currentTime = audioContext.currentTime;

          if (typeof playAudioQueue.lastTime === "undefined") {
            playAudioQueue.lastTime = currentTime;
          }

          // Schedule playback
          outputSource.start(playAudioQueue.lastTime);

          // Update lastTime for next chunk
          playAudioQueue.lastTime += audioBuffer.duration;

          // When playback ends, play the next chunk
          outputSource.onended = () => {
            playAudioQueue();
          };
        } else {
          // Reset lastTime if queue is empty
          playAudioQueue.lastTime = undefined;
        }
      }

      document.getElementById("stopButton").onclick = () => {
        if (processor) {
          processor.disconnect();
        }
        if (source) {
          source.disconnect();
        }
        if (mediaStream) {
          mediaStream.getTracks().forEach((track) => track.stop());
        }
        if (ws) {
          ws.close();
        }
        audioQueue = [];
      };
    </script>
  </body>
</html>
